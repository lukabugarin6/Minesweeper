{"ast":null,"code":"import { InjectMineEnum } from \"../constants/gameConstants\";\nimport { BoardActions } from \"../actions/BoardActions\";\nexport function boardReducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return { ...state,\n        gameOver: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level)\n      };\n\n    case BoardActions.INITIATE_BOARD:\n      return { ...state,\n        minesLeft: payload.level.num_mine,\n        board: resetBoard(state.board, payload.level, payload.row, payload.column),\n        clickNumber: 1\n      };\n\n    default:\n      throw new Error(\"No matching action type in reducer\");\n  }\n}\n\nfunction initiateEmptyBoard({\n  rows,\n  columns\n}) {\n  return Array.from(Array(rows), () => new Array(columns).fill({\n    hasMine: false,\n    isUncovered: false,\n    numMinesAround: 0,\n    flagged: false\n  }));\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n  let numInjectedMines = 0;\n  let tempBoard = JSON.parse(JSON.stringify(emptyBoard));\n  let rowIndex = 0;\n  const indexAroundClickedCell = getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n  while (numInjectedMines < numMine) {\n    for (let i = 0; i < emptyBoard[rowIndex].length; i++) {\n      if (rowIndex === row && i === column) {\n        continue;\n      }\n\n      if (indexAroundClickedCell.includes(JSON.stringify([rowIndex, i]))) {\n        continue;\n      }\n\n      if (numInjectedMines === numMine) {\n        break;\n      }\n\n      const shouldInjectMine = Math.floor(Math.random().Math.floor(10));\n\n      if (shouldInjectMine === InjectMineEnum.INJECT && tempBoard[rowIndex][i].hasMine === false) {\n        tempBoard[rowIndex][i].hasMine = true;\n        numInjectedMines++;\n      }\n    }\n\n    if (rowIndex === emptyBoard.length - 1) {\n      rowIndex = 0;\n    } else {\n      rowIndex++;\n    }\n  }\n\n  return tempBoard;\n}","map":{"version":3,"sources":["/home/s/Desktop/Luka/Projects/minesweeper/src/reducers/boardReducer.js"],"names":["InjectMineEnum","BoardActions","boardReducer","state","type","payload","INITIATE_DUMMY_BOARD","gameOver","clickNumber","minesLeft","level","num_mine","board","initiateEmptyBoard","INITIATE_BOARD","resetBoard","row","column","Error","rows","columns","Array","from","fill","hasMine","isUncovered","numMinesAround","flagged","populateMines","emptyBoard","numMine","numInjectedMines","tempBoard","JSON","parse","stringify","rowIndex","indexAroundClickedCell","getSurroundingCellIndex","map","index","i","length","includes","shouldInjectMine","Math","floor","random","INJECT"],"mappings":"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","sourcesContent":["import { InjectMineEnum } from \"../constants/gameConstants\";\n\nimport { BoardActions } from \"../actions/BoardActions\";\n\nexport function boardReducer(state, { type, payload }) {\n  switch (type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return {\n        ...state,\n        gameOver: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level),\n      };\n    case BoardActions.INITIATE_BOARD:\n        return {\n            ...state,\n            minesLeft: payload.level.num_mine,\n            board: resetBoard(state.board, payload.level, payload.row, payload.column),\n            clickNumber: 1,\n        }\n    default:\n      throw new Error(\"No matching action type in reducer\");\n  }\n}\n\nfunction initiateEmptyBoard({rows, columns}) {\n    return Array.from(\n        Array(rows), () => \n        new Array(columns).fill({\n            hasMine: false,\n            isUncovered: false,\n            numMinesAround: 0,\n            flagged: false\n        })\n    )\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n    let numInjectedMines = 0;\n    let tempBoard = JSON.parse(JSON.stringify(emptyBoard))\n\n    let rowIndex = 0;\n\n    const indexAroundClickedCell = getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n    while(numInjectedMines < numMine) {\n        for(let i = 0;i < emptyBoard[rowIndex].length; i++) {\n            if(rowIndex === row && i === column) {\n                continue;\n            }\n\n            if(indexAroundClickedCell.includes(JSON.stringify([rowIndex,i]))) {\n                continue;\n            }\n\n            if(numInjectedMines === numMine) {\n                break;\n            }\n\n            const shouldInjectMine = Math.floor(Math.random() . Math.floor(10));\n\n            if(shouldInjectMine === InjectMineEnum.INJECT && tempBoard[rowIndex][i].hasMine === false) {\n                tempBoard[rowIndex][i].hasMine = true;\n                numInjectedMines++;\n            }\n        }\n\n        if(rowIndex === emptyBoard.length - 1) {\n            rowIndex = 0;\n        } else {\n            rowIndex++;\n        }\n    }\n    return tempBoard;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { InjectMineEnum } from '../constants/gameConstants';\nimport { BoardActions } from '../actions/BoardActions';\nimport { referenceToAdjacentCells, getSurroundingCellIndex } from '../utility/utility';\nexport function boardReducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return { ...state,\n        gameOver: false,\n        gameClear: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level)\n      };\n\n    case BoardActions.INITIATE_BOARD:\n      return { ...state,\n        minesLeft: payload.level.num_mine,\n        board: resetBoard(state.board, payload.level, payload.row, payload.column),\n        clickNumber: 1\n      };\n\n    case BoardActions.UNCOVER_CELL:\n      return { ...state,\n        board: uncoverCell(state.board, payload.row, payload.column),\n        gameClear: didGameClear(uncoverCell(state.board, payload.row, payload.column))\n      };\n\n    case BoardActions.UNCOVER_ALL_CELLS:\n      return { ...state,\n        board: uncoverAllCells(state.board)\n      };\n\n    case BoardActions.DOUBLE_CLICK_CELL:\n      return { ...state,\n        board: uncoverAdjacentCells(state.board, payload.row, payload.column),\n        gameClear: didGameClear(uncoverAdjacentCells(state.board, payload.row, payload.column))\n      };\n\n    case BoardActions.RIGHT_CLICK_CELL:\n      return { ...state,\n        minesLeft: minesLeft(state.board, payload.row, payload.column, state.minesLeft),\n        board: toggleFlagCell(state.board, payload.row, payload.column),\n        gameClear: didGameClear(toggleFlagCell(state.board, payload.row, payload.column))\n      };\n\n    case BoardActions.CHANGE_LEVEL:\n      return { ...state,\n        gameOver: false,\n        gameClear: false,\n        clickNumber: 0,\n        level: payload.level,\n        minesLeft: payload.level.num_mine,\n        board: initiateEmptyBoard(payload.level)\n      };\n\n    case BoardActions.GAME_OVER:\n      return { ...state,\n        gameOver: true\n      };\n\n    default:\n      throw new Error('No matching action type in reducer');\n  }\n}\n\nfunction initiateEmptyBoard({\n  rows,\n  columns\n}) {\n  return Array.from(Array(rows), () => new Array(columns).fill({\n    hasMine: false,\n    isUncovered: false,\n    numMinesAround: 0,\n    flagged: false\n  }));\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n  let numInjectedMines = 0;\n  let tempBoard = JSON.parse(JSON.stringify(emptyBoard));\n  let rowIndex = 0;\n  const indexAroundClickedCell = getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n  while (numInjectedMines < numMine) {\n    for (let i = 0; i < emptyBoard[rowIndex].length; i++) {\n      if (rowIndex === row && i === column) {\n        continue;\n      }\n\n      if (indexAroundClickedCell.includes(JSON.stringify([rowIndex, i]))) {\n        continue;\n      }\n\n      if (numInjectedMines === numMine) {\n        break;\n      }\n\n      const shouldInjectMine = Math.floor(Math.random() * Math.floor(10));\n\n      if (shouldInjectMine === InjectMineEnum.INJECT && tempBoard[rowIndex][i].hasMine === false) {\n        tempBoard[rowIndex][i].hasMine = true;\n        numInjectedMines++;\n      }\n    }\n\n    if (rowIndex === emptyBoard.length - 1) {\n      rowIndex = 0;\n    } else {\n      rowIndex++;\n    }\n  }\n\n  return tempBoard;\n}\n\nfunction populateNumber(prevBoard) {\n  for (let i = 0; i < prevBoard.length; i++) {\n    for (let j = 0; j < prevBoard[i].length; j++) {\n      const adjacentCells = referenceToAdjacentCells(prevBoard, i, j);\n      let minesAround = 0;\n      adjacentCells.forEach(({\n        cell,\n        row,\n        column\n      }) => {\n        if (cell.hasMine) minesAround++;\n      });\n      prevBoard[i][j].numMinesAround = minesAround;\n    }\n  }\n\n  return prevBoard;\n}\n\n;\n\nfunction resetBoard(board, level, row, column) {\n  let boardWithMines = populateMines(board, level.num_mine, row, column);\n  return populateNumber(boardWithMines, row, column);\n}\n\nfunction minesLeft(board, row, column, minesLeft) {\n  return board[row][column].flagged ? minesLeft + 1 : minesLeft - 1;\n}\n\nfunction uncoverCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].isUncovered = true;\n\n  if (newBoard[row][column].numMinesAround === 0 && !newBoard[row][column].hasMine) {\n    return uncoverAdjacentCells(newBoard, row, column);\n  }\n\n  return newBoard;\n}\n\nfunction toggleFlagCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].flagged = !newBoard[row][column].flagged;\n  return newBoard;\n}\n\nfunction uncoverAdjacentCells(originalBoard, row, column) {\n  const memo = {};\n  const stack = [{\n    cell: originalBoard[row][column],\n    row,\n    column\n  }];\n\n  while (stack.length > 0) {\n    const centerCell = stack.pop();\n    const surroundingCells = referenceToAdjacentCells(originalBoard, centerCell.row, centerCell.column);\n    const flagsInAdjacentCells = surroundingCells.reduce((acc, currCell) => {\n      if (currCell.cell.flagged) return acc + 1;\n      return acc;\n    }, 0);\n    if (flagsInAdjacentCells < centerCell.cell.numMinesAround) return originalBoard;\n\n    for (let cell of surroundingCells) {\n      if (memo[`${cell.row}-${cell.column}`]) continue;else {\n        memo[`${cell.row}-${cell.column}`] = true;\n      }\n      cell.cell.isUncovered = cell.cell.flagged ? false : true;\n\n      if (cell.cell && !cell.cell.numMinesAround && !cell.cell.hasMine) {\n        stack.push(cell);\n      }\n    }\n  }\n\n  return originalBoard;\n}\n\n;\n\nfunction didGameClear(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      if (!board[i][j].hasMine && !board[i][j].isUncovered) {\n        return false;\n      }\n\n      if (!board[i][j].hasMine && board[i][j].flagged) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/s/Desktop/Luka/Projects/minesweeper/src/reducers/boardReducer.js"],"names":["InjectMineEnum","BoardActions","referenceToAdjacentCells","getSurroundingCellIndex","boardReducer","state","type","payload","INITIATE_DUMMY_BOARD","gameOver","gameClear","clickNumber","minesLeft","level","num_mine","board","initiateEmptyBoard","INITIATE_BOARD","resetBoard","row","column","UNCOVER_CELL","uncoverCell","didGameClear","UNCOVER_ALL_CELLS","uncoverAllCells","DOUBLE_CLICK_CELL","uncoverAdjacentCells","RIGHT_CLICK_CELL","toggleFlagCell","CHANGE_LEVEL","GAME_OVER","Error","rows","columns","Array","from","fill","hasMine","isUncovered","numMinesAround","flagged","populateMines","emptyBoard","numMine","numInjectedMines","tempBoard","JSON","parse","stringify","rowIndex","indexAroundClickedCell","map","index","i","length","includes","shouldInjectMine","Math","floor","random","INJECT","populateNumber","prevBoard","j","adjacentCells","minesAround","forEach","cell","boardWithMines","originalBoard","newBoard","memo","stack","centerCell","pop","surroundingCells","flagsInAdjacentCells","reduce","acc","currCell","push"],"mappings":"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","sourcesContent":["import { InjectMineEnum } from '../constants/gameConstants';\n\nimport { BoardActions } from '../actions/BoardActions';\nimport { referenceToAdjacentCells, getSurroundingCellIndex } from '../utility/utility';\n\nexport function boardReducer (state, { type, payload }) {\n  switch(type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return {\n        ...state,\n        gameOver: false,\n        gameClear: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level),\n      };\n\n    case BoardActions.INITIATE_BOARD:\n      return {\n        ...state,\n        minesLeft: payload.level.num_mine,\n        board: resetBoard(state.board, payload.level, payload.row, payload.column),\n        clickNumber: 1,\n      };\n\n    case BoardActions.UNCOVER_CELL:\n      return {\n        ...state,\n        board: uncoverCell(state.board, payload.row, payload.column),\n        gameClear: didGameClear(uncoverCell(state.board, payload.row, payload.column)),\n      };\n    case BoardActions.UNCOVER_ALL_CELLS:\n      return {\n        ...state,\n        board: uncoverAllCells(state.board)\n      }\n    case BoardActions.DOUBLE_CLICK_CELL:\n      return {\n        ...state,\n        board: uncoverAdjacentCells(state.board, payload.row, payload.column),\n        gameClear: didGameClear(uncoverAdjacentCells(state.board, payload.row, payload.column)),\n      };\n\n    case BoardActions.RIGHT_CLICK_CELL:\n      return {\n        ...state,\n        minesLeft: minesLeft(state.board, payload.row, payload.column, state.minesLeft),\n        board: toggleFlagCell(state.board, payload.row, payload.column),\n        gameClear: didGameClear(toggleFlagCell(state.board, payload.row, payload.column)),\n      };\n\n    case BoardActions.CHANGE_LEVEL:\n      return {\n        ...state,\n        gameOver: false,\n        gameClear: false,\n        clickNumber: 0,\n        level: payload.level,\n        minesLeft: payload.level.num_mine,\n        board: initiateEmptyBoard(payload.level),\n      };\n    \n    case BoardActions.GAME_OVER:\n      return {\n        ...state,\n        gameOver: true,\n      };\n\n    default:\n      throw new Error('No matching action type in reducer');\n  }\n}\n\nfunction initiateEmptyBoard({ rows, columns }) {\n  return Array.from(\n    Array(rows), () =>\n    new Array(columns).fill({\n      hasMine: false,\n      isUncovered: false,\n      numMinesAround: 0,\n      flagged: false,\n    })\n    );\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n  let numInjectedMines = 0;\n  let tempBoard = JSON.parse(JSON.stringify(emptyBoard));\n\n  let rowIndex = 0;\n\n  const indexAroundClickedCell= getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n  while(numInjectedMines < numMine) {\n    for(let i=0; i < emptyBoard[rowIndex].length; i++) {\n      if(rowIndex === row && i === column) {\n        continue;\n      }\n\n      if(indexAroundClickedCell.includes(JSON.stringify([rowIndex, i]))) {\n        continue;\n      }\n\n      if(numInjectedMines === numMine) {\n        break;\n      }\n\n      const shouldInjectMine = Math.floor(Math.random() * Math.floor(10));\n\n      if(shouldInjectMine === InjectMineEnum.INJECT && \n        tempBoard[rowIndex][i].hasMine === false\n        ) {\n        tempBoard[rowIndex][i].hasMine = true;\n        numInjectedMines++;\n      }\n    }\n    \n    if (rowIndex === emptyBoard.length - 1) {\n      rowIndex = 0;\n    } else {\n      rowIndex++;\n    }\n  }\n  return tempBoard;\n}\n\nfunction populateNumber(prevBoard) {\n  for(let i=0; i <prevBoard.length; i++) {\n    for(let j=0; j<prevBoard[i].length; j++) {\n      const adjacentCells = referenceToAdjacentCells(prevBoard, i, j);\n      let minesAround = 0;\n      adjacentCells.forEach(({cell, row, column}) => {\n        if(cell.hasMine) minesAround++;\n      })\n\n      prevBoard[i][j].numMinesAround = minesAround;\n    }\n  }\n  return prevBoard;\n};\n\nfunction resetBoard(board, level, row, column) {\n  let boardWithMines = populateMines(board, level.num_mine, row, column);\n  return populateNumber(boardWithMines, row, column);\n}\n\nfunction minesLeft(board, row, column, minesLeft) {\n  return board[row][column].flagged ? minesLeft + 1: minesLeft - 1\n}\n\nfunction uncoverCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].isUncovered = true;\n  if(newBoard[row][column].numMinesAround === 0 && !newBoard[row][column].hasMine) {\n    return uncoverAdjacentCells(newBoard, row, column);\n  }\n  return newBoard;\n}\n\nfunction toggleFlagCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].flagged = !newBoard[row][column].flagged;\n  return newBoard\n}\n\nfunction uncoverAdjacentCells(originalBoard, row, column) {\n  const memo = {};\n  const stack = [{ cell: originalBoard[row][column], row, column }];\n\n  while(stack.length > 0) {\n    const centerCell = stack.pop();\n    const surroundingCells = referenceToAdjacentCells(originalBoard, centerCell.row, centerCell.column);\n    \n    const flagsInAdjacentCells = surroundingCells.reduce((acc, currCell) => {\n      if(currCell.cell.flagged) return acc + 1;\n      return acc;\n    }, 0);\n\n    if (flagsInAdjacentCells < centerCell.cell.numMinesAround) return originalBoard;\n\n    for (let cell of surroundingCells) {\n      if(memo[`${cell.row}-${cell.column}`]) continue;\n      else {\n        memo[`${cell.row}-${cell.column}`] = true;\n      }\n\n      cell.cell.isUncovered = cell.cell.flagged ? false : true;\n\n      if(cell.cell && !cell.cell.numMinesAround && !cell.cell.hasMine) {\n        stack.push(cell);\n      }\n    }\n  }\n\n  return originalBoard;\n};\n\nfunction didGameClear(board) {\n  for(let i=0; i < board.length; i++) {\n    for(let j=0; j < board[0].length; j++) {\n      if(!board[i][j].hasMine && !board[i][j].isUncovered) {\n        return false;\n      }\n\n      if(!board[i][j].hasMine && board[i][j].flagged) {\n        return false;\n      }\n    }\n  }\n  return true;\n}"]},"metadata":{},"sourceType":"module"}
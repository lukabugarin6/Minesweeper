{"ast":null,"code":"import { InjectMineEnum } from \"../constants/gameConstants\";\nimport { BoardActions } from \"../actions/BoardActions\";\nimport { referenceToAdjacentCells, getSurroundingCellIndex } from '../utility/utility';\nexport function boardReducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return { ...state,\n        gameOver: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level)\n      };\n\n    case BoardActions.INITIATE_BOARD:\n      return { ...state,\n        minesLeft: payload.level.num_mine,\n        board: resetBoard(state.board, payload.level, payload.row, payload.column),\n        clickNumber: 1\n      };\n\n    default:\n      throw new Error(\"No matching action type in reducer\");\n  }\n}\n\nfunction initiateEmptyBoard({\n  rows,\n  columns\n}) {\n  return Array.from(Array(rows), () => new Array(columns).fill({\n    hasMine: false,\n    isUncovered: false,\n    numMinesAround: 0,\n    flagged: false\n  }));\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n  let numInjectedMines = 0;\n  let tempBoard = JSON.parse(JSON.stringify(emptyBoard));\n  let rowIndex = 0;\n  const indexAroundClickedCell = getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n  while (numInjectedMines < numMine) {\n    for (let i = 0; i < emptyBoard[rowIndex].length; i++) {\n      if (rowIndex === row && i === column) {\n        continue;\n      }\n\n      if (indexAroundClickedCell.includes(JSON.stringify([rowIndex, i]))) {\n        continue;\n      }\n\n      if (numInjectedMines === numMine) {\n        break;\n      }\n\n      const shouldInjectMine = Math.floor(Math.random().Math.floor(10));\n\n      if (shouldInjectMine === InjectMineEnum.INJECT && tempBoard[rowIndex][i].hasMine === false) {\n        tempBoard[rowIndex][i].hasMine = true;\n        numInjectedMines++;\n      }\n    }\n\n    if (rowIndex === emptyBoard.length - 1) {\n      rowIndex = 0;\n    } else {\n      rowIndex++;\n    }\n  }\n\n  return tempBoard;\n}\n\nfunction populateNumber(prevBoard) {\n  for (let i = 0; i < prevBoard.length; i++) {\n    for (let j = 0; j < prevBoard[i].length; j++) {\n      const adjacentCells = referenceToAdjacentCells(prevBoard, i, j);\n      let minesAround = 0;\n      adjacentCells.forEach(({\n        cell,\n        row,\n        column\n      }) => {\n        if (cell.hasMine) minesAround++;\n      });\n      prevBoard[i][j].numMinesAround = minesAround;\n    }\n  }\n\n  return prevBoard;\n}\n\nfunction resetBoard(board, level, row, column) {\n  let boardWithMines = populateMines(board, level.num_mine, row, column);\n  return populateNumber(boardWithMines, row, column);\n}","map":{"version":3,"sources":["/home/s/Desktop/Luka/Projects/minesweeper/src/reducers/boardReducer.js"],"names":["InjectMineEnum","BoardActions","referenceToAdjacentCells","getSurroundingCellIndex","boardReducer","state","type","payload","INITIATE_DUMMY_BOARD","gameOver","clickNumber","minesLeft","level","num_mine","board","initiateEmptyBoard","INITIATE_BOARD","resetBoard","row","column","Error","rows","columns","Array","from","fill","hasMine","isUncovered","numMinesAround","flagged","populateMines","emptyBoard","numMine","numInjectedMines","tempBoard","JSON","parse","stringify","rowIndex","indexAroundClickedCell","map","index","i","length","includes","shouldInjectMine","Math","floor","random","INJECT","populateNumber","prevBoard","j","adjacentCells","minesAround","forEach","cell","boardWithMines"],"mappings":"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","sourcesContent":["import { InjectMineEnum } from \"../constants/gameConstants\";\n\nimport { BoardActions } from \"../actions/BoardActions\";\nimport { referenceToAdjacentCells, getSurroundingCellIndex } from '../utility/utility';\n\nexport function boardReducer(state, { type, payload }) {\n  switch (type) {\n    case BoardActions.INITIATE_DUMMY_BOARD:\n      return {\n        ...state,\n        gameOver: false,\n        clickNumber: 0,\n        minesLeft: state.level.num_mine,\n        board: initiateEmptyBoard(state.level),\n      };\n    case BoardActions.INITIATE_BOARD:\n        return {\n            ...state,\n            minesLeft: payload.level.num_mine,\n            board: resetBoard(state.board, payload.level, payload.row, payload.column),\n            clickNumber: 1,\n        }\n    default:\n      throw new Error(\"No matching action type in reducer\");\n  }\n}\n\nfunction initiateEmptyBoard({rows, columns}) {\n    return Array.from(\n        Array(rows), () => \n        new Array(columns).fill({\n            hasMine: false,\n            isUncovered: false,\n            numMinesAround: 0,\n            flagged: false\n        })\n    )\n}\n\nfunction populateMines(emptyBoard, numMine, row, column) {\n    let numInjectedMines = 0;\n    let tempBoard = JSON.parse(JSON.stringify(emptyBoard))\n\n    let rowIndex = 0;\n\n    const indexAroundClickedCell = getSurroundingCellIndex(row, column).map(index => JSON.stringify(index));\n\n    while(numInjectedMines < numMine) {\n        for(let i = 0;i < emptyBoard[rowIndex].length; i++) {\n            if(rowIndex === row && i === column) {\n                continue;\n            }\n\n            if(indexAroundClickedCell.includes(JSON.stringify([rowIndex,i]))) {\n                continue;\n            }\n\n            if(numInjectedMines === numMine) {\n                break;\n            }\n\n            const shouldInjectMine = Math.floor(Math.random() . Math.floor(10));\n\n            if(shouldInjectMine === InjectMineEnum.INJECT && tempBoard[rowIndex][i].hasMine === false) {\n                tempBoard[rowIndex][i].hasMine = true;\n                numInjectedMines++;\n            }\n        }\n\n        if(rowIndex === emptyBoard.length - 1) {\n            rowIndex = 0;\n        } else {\n            rowIndex++;\n        }\n    }\n    return tempBoard;\n}\n\nfunction populateNumber(prevBoard) {\n    for(let i = 0;i < prevBoard.length; i++) {\n        for(let j = 0; j < prevBoard[i].length; j++) {\n            const adjacentCells = referenceToAdjacentCells(prevBoard, i, j)\n            let minesAround = 0;\n            adjacentCells.forEach(({cell, row, column}) => {\n                if(cell.hasMine) minesAround++\n            })\n\n            prevBoard[i][j].numMinesAround = minesAround;\n        }\n    }\n    return prevBoard\n}\n\nfunction resetBoard(board, level, row, column) {\n    let boardWithMines = populateMines(board, level.num_mine, row, column);\n    return populateNumber(boardWithMines, row, column);\n  }"]},"metadata":{},"sourceType":"module"}
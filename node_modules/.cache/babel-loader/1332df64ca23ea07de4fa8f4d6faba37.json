{"ast":null,"code":"export function getSurroundingCellIndex(row, column) {\n  return [[row - 1, column - 1], [row - 1, column], [row - 1, column + 1], [row, column - 1], [row, column + 1], [row + 1, column - 1], [row + 1, column], [row + 1, column + 1]];\n}\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n  const adjacentCells = [];\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(originalBoard, newRow, newColumn)) {\n      adjacentCells.push({\n        cell: originalBoard[newRow][newColumn],\n        row: newRow,\n        column: newColumn\n      });\n    }\n  }\n\n  return adjacentCells;\n}","map":{"version":3,"sources":["/home/s/Desktop/Luka/Projects/minesweeper/src/utility/utility.js"],"names":["getSurroundingCellIndex","row","column","referenceToAdjacentCells","originalBoard","adjacentCells","surroundingCellIndex","newRow","newColumn","isCell","push","cell"],"mappings":"AAAA,OAAO,SAASA,uBAAT,CAAiCC,GAAjC,EAAsCC,MAAtC,EAA8C;AACjD,SAAO,CACL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CADK,EAEL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAV,CAFK,EAGL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CAHK,EAIL,CAACD,GAAD,EAAMC,MAAM,GAAG,CAAf,CAJK,EAKL,CAACD,GAAD,EAAMC,MAAM,GAAG,CAAf,CALK,EAML,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAE,CAAlB,CANK,EAOL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAV,CAPK,EAQL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CARK,CAAP;AAUH;AAED,OAAO,SAASC,wBAAT,CAAkCC,aAAlC,EAAiDH,GAAjD,EAAsDC,MAAtD,EAA8D;AACjE,QAAMG,aAAa,GAAG,EAAtB;AAEA,QAAMC,oBAAoB,GAAGN,uBAAuB,CAACC,GAAD,EAAMC,MAAN,CAApD;;AAEA,OAAI,IAAI,CAACK,MAAD,EAASC,SAAT,CAAR,IAA+BF,oBAA/B,EAAqD;AAEnD,QAAIG,MAAM,CAACL,aAAD,EAAgBG,MAAhB,EAAwBC,SAAxB,CAAV,EAA8C;AAC5CH,MAAAA,aAAa,CAACK,IAAd,CAAmB;AACjBC,QAAAA,IAAI,EAAEP,aAAa,CAACG,MAAD,CAAb,CAAsBC,SAAtB,CADW;AAEjBP,QAAAA,GAAG,EAAEM,MAFY;AAGjBL,QAAAA,MAAM,EAAEM;AAHS,OAAnB;AAKD;AACF;;AAED,SAAOH,aAAP;AACD","sourcesContent":["export function getSurroundingCellIndex(row, column) {\n    return [\n      [row - 1, column - 1],\n      [row - 1, column],\n      [row - 1, column + 1],\n      [row, column - 1],\n      [row, column + 1],\n      [row + 1, column -1],\n      [row + 1, column],\n      [row + 1, column + 1],\n    ];\n}\n\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n    const adjacentCells = [];\n  \n    const surroundingCellIndex = getSurroundingCellIndex(row, column);\n  \n    for(let [newRow, newColumn] of surroundingCellIndex) {\n  \n      if (isCell(originalBoard, newRow, newColumn)) {\n        adjacentCells.push({\n          cell: originalBoard[newRow][newColumn],\n          row: newRow,\n          column: newColumn,\n        });\n      }\n    }\n  \n    return adjacentCells;\n  }"]},"metadata":{},"sourceType":"module"}